
## メソッドとは
- 段取り
- 手順
プログラミングじゃなくても○○メソッドとかいうやつ

手順書
1. Aから実行している途中でBをやれと書いてある
2. Bの手順書を探して、一番上から順番にやる
3. 途中でCをやれと書いてある
4. Cを一番最初からやる
5. Cが全部終わる
6. Bの途中（続き）から実行し完了
7. Aの途中（続き）から実行し完了
8. 全て終了🙌

Aの前半->Bの前半->C全部->Bの後半->Aの後半

図にかけば理解できる✨
![三つの手順A B Cが順番に入れ子になって進行し、Cが終わるとBの残り、最後にAの残りを実行する流れを示す手順図。背景は白で、手順の流れを矢印で示している。](../images/3−1.jpeg)

![A B Cの手順が階層的に並び、CがBの中に、BがAの中に入っている構造を示す図。手順の順序が視覚的に分かるように色分けされている。背景はシンプルで、手順名が大きく表示されている。](../images/3-2.jpeg)

### 何故ひとつの手順書にしないのか？

凄く長くなってしまうので手順書を分けたい

1. 全体の処理を１ずつ分かりやすくするため
2. 再利用しやすくするため

問題は順番を間違えてしまわないか

FILO（フィロ）の構造 = バケツを持っている
メモリ領域（スタック領域で順番を管理する

スタック領域（メモリ領域）とは
下から積み上げる
取り出す時は上から
->逆になる = 先入後出し

図に書いたら分かるよ

1. Aのスタックフレームの上にBのスタックフレームを積み上げる（Cをやれと書いてる）
2. その上にCのスタックフレームを積み上げる
3. C全部取り外し
4. B残り取り外し
5. A残り取り外し

全部終わったら処理完了

![スタック構造を示す図。A B Cのフレームが下から順に積み上げられ、Cが一番上にある。処理が終わるごとに上から順にフレームが取り外される様子が矢印で示されている。背景は白で、各フレームにA B Cと大きく書かれている。](../images/3-3.jpeg)

## スタック領域

スタック領域に積み上げられるのは**メソッドの定義のコピー** = スタックフレームという

四角の積み上げられるのはスタック領域

スタック領域 = 手順書(順番) + スタックフレーム(梯子の絵 = 保存領域)

常に上からしか見てないので、Aの途中であればBを積み上げる

⭐️領域を飛び越えてアクセスできない->どのタイミングでどんな処理をするかわからなくなるから

->領域を飛び越えて(スタックフレームを跨いで)の処理はできない

では、違うスタックフレームのデータを使いたい場合は？

->Aの上のBに**コピー**を渡せば良い(引数)

###  ⭐️引数とは = 処理の実行するために必要なデータのこと

**引数**は必要なデータであり、このデータがないと処理を進められない->コンパイルエラーになっちゃう

AにBを積み上げた時にはAのデータのコピーを渡せば良い(引数)

元あるデータをコピーして渡されたデータのこと

引数を宣言して使う

受け取る側はどこにデータを入れておく？

入れてもらったら初めて1行目の処理が始まる

スタックフレームを取り外す前に、コピーしたデータを戻すことができる(戻り値)

データを渡されたらどこに入れる？->自分のローカル変数しか使えないので

1. そのコピーを入れる
2. Bの処理が始まる

途中にCをやれと書いてあるので、データをコピーしてCに渡す->Cはローカル変数にアクセスして処理を開始

->Cの処理が終わったらCを消さないと次の処理ができない

->Cを取り外す前にデータを渡さないとBの処理ができない

->CはデータのコピーをBに渡す

⭐️コピーして渡す、コピーして渡すの繰り返し

voidは引数を渡さない

voidの後のが**メソッド**

プログラミングとは：考えること

## mainメソッド

⭐️エントリーポイント

⭐️メソッド呼び出しをする

⭐️`static`を足すとエントリーポイントで`a();`を書くと出力される

```java
// mainがありませんエラー
public class Main {
	public void a() {
		System.out.println(“a”);
    }
}
```
引数を渡さないと処理できない

互換性のあるデータ(StringならString,intならint)

受け取るための準備が必要

バケツの上に積み上げたいのに引数を渡さないからエラー

⇩ 修正
```java
// 複数のメソッドがあってどこから始めていいのか分からなくなる
public class Main {
	public void a() {
		System.out.println(“a”);
}
	public void b() {
		System.out.println(“b”);
}
	public void c() {
	System.out.println(“c”);
}
public static void main(String[] args){
    a();
    b();
    c();
}
}

```

実行したら

```java
a
b
c
```

### 同じクラスの場合

`main`メソッドに`static`を使ったら`static`を使うこと

`static`を使わないなら**インスタンス化**する必要がある

◆引数を使う

`String`型の引数を使う(宣言する)


引数の宣言の型と受け取る型は、必ず合わせる


```java
public class Main {
	public static void a(Strint str) {
		System.out.println(“a”);
}
	public static void b(int num) {
		System.oiut.println(“b”);
}
	public static void c(String a, int b) {
	System.out.println(“c”);
}
public static void main(String[] args)
	a(“hoge);
	b(100);
	c(“a”, 100);
}
```

String型のstrをメモリに保存

mainからhogeを渡す

戻り値の型を宣言するのは**void**

```java
public static int calc(int a, int b) {
	int result = a + b; // aに２、bに３が入る
	return result;　// 5
}
public static void main String[] args) {
	result = cal

```

```java

public class Sample {
	// このコピーをスタックフレームに積み上げる
	public static void calc(int a, int b) {
		if (b < 10) {
			System.out.print(a * b);
			calc(a, b + 1);
		}
	// ここまで
	}
	calcに３と1を渡すと？どうなる？
	public static void main(String[] args) {
		calc(3, 1);
	}
}
```

bが10より小さい間、３× 1が実行される
```
a = 3
b = 1
```

**目の前のコードではなく、コピーが動いてる**

新しいメソッドが作られるのは、新しいメソッドのコピーが作られる

九九表を作る

繰り返し文を使わず1つメソッドを追加すればできる

何をしなきゃいけないかを分からなければできない

エンジニアはアイディアMan！！

```java
public class Sample {
	public static void calc(int a, int b) {
		if (b < 10) {
			System.out.print(a * b);
			calc(a, b + 1);
		}
	}

	public static void line(int a) {
		if (a < 10) {
			line(a + 1);
		}
	}

	public static void main(String[] args) {
		line(1); // 1の段
	}
}
```
