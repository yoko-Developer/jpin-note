## 引数と戻り値

値が代入されてから初めて処理が実行される
引数がないと処理が実行されない
処理が入らない限り1行目を実行してはいけないというルール
**引数の形を揃える**か**オーバーロード**するかじゃないと、コンパイルエラーになる

データを渡すときの変数名、受け取るときの変数名は同じでも違っても良い！！->ブロックが違うからね
1. 変数宣言
2. 変数に値を代入
3. 処理スタート
メソッド内のみで有効だから、異なるスタックフレームで変数名が同じでも値は違う

絵を描きながら説明しよう
もしbが10より小さければ、bを1プラスする

**再帰呼び出し**＝自分自身を呼び出すのではない
メソッドの再帰呼び出し＝自分の中で同じ定義の新しいコピーを作ってスタックフレームに積み上げている

※常にコピーされている
同じ定義でも違うコピーがどんどん作られる
次々とコピーが呼び出される
※目の前のコードが動いてるわけではない
※わからないという言葉禁止！！
->代わりに「慣れてない」と言いましょう🩷

スタックフレームに積まれるのはコピーだ！！
コピーしたものがスタックフレームに積まれる！！

引数はコピーを渡して、戻り値はコピーを戻す
大きいデータの時にはコピーして渡すのか？？->非効率的

効率よくデータを扱うために、処理の順番を決める
処理の順番を決める＝データの場所（ヒープ領域）
スタック領域＝処理の順番を制御する
ヒープ領域＝データを一旦置いておく場所
大きいデータを一旦置き、番地指定したデータのコピーを渡す

リンク情報のことを「参照」という

データのアドレスをスタック領域に渡す。スタック領域からヒープ領域に見に行く
スタック領域にあるのはリンク先のURLで、実際のデータはヒープ領域にある
リンク情報を見に行く（参照という）
リンク情報はヒープ領域のみの情報
->メモリアドレスなので、小さくなり処理が早くなる
配列：一度にたくさんのデータを扱う（大きなデータの代表例）

ヒープで作った配列の本体をスタックから参照する

スタックとヒープ2つの梯子に増える
メモリアドレスに名前をつけただけ＝変数宣言
int[] array

ヒープに領域を確保しなさい＝new
new int[3]
配列の中身（インスタンス）を200番地に置く


変数arrayでもarray2でも同じ場所にアクセスするという検証のコードを書く
