## オーバーロード（多重定義）

メソッドの名前：識別子

同じ名前のメソッドでも引数が異なれば、同じメソッドを複数定義できる

引数が異なるとは
- 引数の数
- 引数の順番
- 引数の型
⇧このセットのことを**シグニチャ**という

'return'はこれ以上進まない
だからスタックフレームから取り外してということ

目の前のコードが動いているわけではない
コピーが動いている！！

コピーを取りなさいというのは201
インスタンスとインスタンスが数珠繋ぎになっていることが理解できると良い
->絵で考えると裏側でJVMが何をやってるかが分かる
![](images/overload1.jpeg)

⭐️コンストラクタのルール
- **メソッド名**と**クラス名**は同じでなければならない

- Mutable: 可変オブジェクト
- Immutable: 不変オブジェクト

カプセル化: Cは3/5というデータを使って何かを戻す
不変条件が変わってしまうと、安心して使えない
CオブジェクトはMutableオブジェクトなので3/6になるかも

Aが3/6に変更するメソッドをCに対して送ると
Cは内部で変更せず、Dという3/6のデータを持つインスタンスを作成する

⇩DBに例える
Mutable＝何でもできる
Immutable：updateがない

設計する時にはMutableかImmutableにするかを考えなきゃならない
Mutableでなければならない場合->人間オブジェクトの年齢が変わる時にオブジェクトがたくさんあるとおかしい
（1歳増えるごとに同じ人間が増えることになるから）

非同期処理とは：1つのタスクを実行中でも他のタスクを実行できること
画面表示しながらDBからデータを持ってきて処理を実行することができる

カプセル化ではgetter使用すると違反⚠️
本来、処理はそのクラスになければならない

データとルールを1セットで扱わないとルールが点在することになってしまう

priceクラス（値オブジェクト）を作るのは
1. ルールに当てはまる値だと保証するため
2. ルールを色んなクラスに描かなくて良くするため

⭐️重要：そのデータを持ってるクラスの中で計算させる

動くだけのプログラムを作ればいいというものではない
->面倒くさくオブジェクト指向にしているが、その分安全だったし趣旨が違う

◆宿題
`List`クラスに2つのメソッドを追加
`size`メソッドと`get`メソッドを追加する

`getter`を排除する
✨ヒント
```java
public Price add(Price price) {
    return new Price;
}
```
